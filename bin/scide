#!/usr/bin/env bash
set -e

version=2.0.1

bold=1
red=31
green=32
yellow=33
magenta=35
cyan=36
gray=90

function cleanup() {
  local tmp_dir="$1"
  test -n "$tmp_dir" && test -d "$tmp_dir" && rm -fr "$tmp_dir"
}

function command_exists() {
  local command="$1"
  hash "$command" &>/dev/null
}

function fail() {
  local code="$1"
  shift
  >&2 echo "$@"
  exit $code
}

function log_color() {
  local color="$1"
  shift
  local message="$@"

  if is_interactive; then
    >&2 echo -e "\033[${color}m${message}\033[0m"
  else
    >&2 echo "$message"
  fi
}

function is_interactive() {
  test "${-#*i}" != "$-" || test -t 0 || test -n "$PS1"
}

function is_relative() {
  local path="$1"
  [[ "$path" = /* || "$path" = ~* ]]
}

tmp_dir=`mktemp -d -t scide.XXXXXX`
trap "cleanup $tmp_dir" EXIT

auto="${SCIDE_AUTO:-false}"
dry_run="${SCIDE_DRY_RUN:-false}"
projects_dir="$SCIDE_PROJECTS"
screen_bin="${SCIDE_BIN:-screen}"
screen_default_config="${SCIDE_DEFAULT:-$HOME/.config/scide/.screenrc}"
screen_options="${SCIDE_SCREEN:-"-U"}"

default_screenrc=$(cat <<-EOF
source \$HOME/.screenrc
screen -t editor 0
stuff "\$EDITOR\\012"
screen -t shell 1
select editor
EOF
)

positional_args=()
while [[ "$#" -gt 0 ]]; do
  option="$1"
  shift

  case "$option" in
    -a|--auto)
      auto=true
    ;;
    -b|--bin)
      screen_bin="$1"
      shift
    ;;
    -d|--dry-run)
      dry_run=true
    ;;
    -p|--projects)
      projects_dir="$1"
      shift
    ;;
    -s|--screen)
      screen_options="$1"
      shift
    ;;
    -t|--default)
      screen_default_config="$1"
      shift
    ;;
    -v|--version)
      echo "$(basename "$0") $version"
      exit 0
    ;;
    *)
      positional_args+=("$option")
    ;;
  esac
done

# Restore positional parameters.
set -- "${positional_args[@]}"

target="$1"

# Check screen command availability.
if ! command_exists "$screen_bin"; then
  if test -e "$screen_bin"; then
    test -x "$screen_bin" || fail 101 "screen binary $screen_bin is not executable"
    is_relative "$screen_bin" && [[ "$screen_bin" == . ]] || screen_bin="./$screen_bin"
  else
    fail 100 "screen binary $screen_bin not found"
  fi
fi

# Determine path to configuration file.
config_file=".screenrc"
if test -f "$target"; then
  config_file="$target"
  test -r "$config_file" || fail 103 "$config_file is not readable"
elif test -d "$target"; then
  config_file="${target}/.screenrc"
  test -x "$target" || fail 103 "directory $target is not traversable"
  test -f "$config_file" || fail 102 ".screenrc not found in directory $target"
  test -r "$config_file" || fail 103 "$config_file is not readable"
elif test -e "$target"; then
  fail 104 "$target is not a file or directory"
elif [[ "$auto" == "true" ]]; then
  # Generate temporary configuration file.
  config_file="${tmp_dir}/.screenrc"
  if test -r "$screen_default_config"; then
    cat "$screen_default_config" > "$config_file"
  elif test -e "$screen_default_config"; then
    fail 103 "default configuration file ${screen_default_config} is not readable"
  else
    echo "$default_screenrc" > "$config_file"
  fi
else
  test -e "$config_file" || fail 102 "$config_file not found in current directory $PWD"
  test -r "$config_file" || fail 103 "$config_file in $PWD is not readable"
fi

command=("$screen_bin" $screen_options -c "$config_file")

if [ "$dry_run" = "true" ]; then
  echo "${command[@]}"
else
  "${command[@]}"
fi
